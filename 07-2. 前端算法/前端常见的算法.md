算法复杂度：
1. 时间复杂度：
    O(1): 常数复杂度，与数据量无关。如从数组中取第i个元素arr[i]
    O(log n): 对数复杂度，每次二分。
    O(n): 线性时间复杂度。如数组遍历一次。
    O(n*log n): 线性对数。遍历二分
    O(n^2): 平方，两层遍历。从这开始意味着算法基本不可用。
    O(n^3): 立方
    O(2^n): 指数
    O(n!): 阶乘
2. 空间复杂度:
    有没有借助新的数组或变量来完成操作, 如果没有则认为空间复杂度为O(1)

常见算法：
1. 排序：
    冒泡排序:  时间复杂度O(n^2), 空间复杂度O(1)
        依次比较两个相邻的元素, 如果顺序错误则将它们进行交换. 完成一次循环会最大的数往右边放。
    插入排序:  时间复杂度O(n^2), 空间复杂度O(1)
        与冒泡排序逻辑相似，不是进行相邻元素的挨个交换，而是每次在一个有序数组里插入一个元素，使数组依然有序。
    快速排序: 时间复杂度O(n*log n)
        二分+递归
        从数组中取出一个标志位(如第1个), 遍历数组将数组以标志位为参考值分成左右两边，小的放左边，大的放右边，递归重复进行上述操作，直到数组长度小于等于1时停止。
        优化：原地快排，不占用额外空间
2. 递归：
    例： 数组打平，爬楼问题(斐波那契数列)
3. 查找：
    二分查找: 从一个有序的数组中查找到某个数的位置
    递归查找：

算法技巧：
    动态规划：
        斐波那契数列问题：
            暴力递归fib: 复杂度O(2^n), 指数级别，算法基本不可取
            中间存储fib: 复杂度O(n), 自顶向下
            动态规划fib: 复杂度O(n), 自底向上, 动态规划一般都脱离了递归，而是由循环迭代完成计算.
        找零钱问题：假如有1, 5, 10, 20 ,50, 100的人民币, 怎么找对应金额的零钱?
    贪心算法：
        找零钱问题：

数据结构：
    队列：先入先出
    链表：
    集合：Set
    哈希表：
    树：dom
  

算法书籍推荐：
    算法第四版：https://book.douban.com/subject/10432347/
    啊哈算法：https://book.douban.com/subject/26979890/

