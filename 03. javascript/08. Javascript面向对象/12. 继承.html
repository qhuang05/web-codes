<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>继承</title>
    <script>
        function A() {
            this.name = 'blue';
            this.hobby = ['football','basketball'];
        }
        A.prototype.showName = function () {
            alert(this.name);
        }

        //继承A
        function B() {
            A.call(this);		//通过call来继承A的属性,这里的this指的是B对象
            // 使用call可以继承实例属性，而不能继承原型属性。为什么？
            // 因为A.call(this)在这里可以简单粗暴理解为此处执行了A函数：
            // this.name = 'blue',
            // this.hobby = ['football', 'basketball'];
            // 当B进行实例化b后，this指代的就是b
            // 而B.prototype指向的与A.prototype其实是一样的，都指向Object.prototype
        }

        // B.prototype=A.prototype;	//如果通过这种方法,当在B上添加特定的方法时,也会同时在A上加上这些方法,因为使用了引用这个概念
        for (var i in A.prototype) {
            B.prototype[i] = A.prototype[i];
        }
        B.prototype.fn = function () {
            alert('fnn');
        };
        var objB = new B();
        var objA = new A();
        alert(objB.name);		//=blue
        objB.fn();				//=fnn
        objA.fn();				//会报错,objA上没有定义fn这个方法
    </script>
</head>
<body>

</body>
</html>