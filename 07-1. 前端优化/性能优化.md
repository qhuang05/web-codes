vue, react, node, webpack, 性能, 安全, 算法, 设计模式
移动端开发：微信公众号, 微信小程序->多端开发方案uni-app, taro
========================================================= 
性能优化宏观指标：文件少加载, 代码少执行
从输入url到显示页面, 到底发生了什么? 从前端角度,性能优化的目标，就是整体时间变短
雅虎军规：


性能分析：
window.performance.timing
chrome浏览器的performance工具使用
lighthouse:
    npm install lighthouse -g
    lighthouse http://www.baidu.com --view 

页面打开的时间最长不能超过5s, 一般控制在3s内.
图片一般控制在多少KB比较合适? 没有固定答案, 大图保证清晰度和像素情况下尽可能压缩.
api请求时间一般多少ms算慢? 没有固定答案, 一般是ms级.



一、图片优化：
1. 图片格式选择与压缩
png
运行pngcrush或其它工具压缩png. https://tinypng.com/
运行jpegtran或其它工具压缩jpeg
大图用jpg
svg矢量图
wbbP(兼容性，chrome支持得比较好, 根据不同的浏览器加载不同类型的图片)
Base64
2. css雪碧图：减少http请求
3. 其它：
图片渐近显示(先显示低分辨率，然后显示高的)
懒加载
骨架图

二、css优化：
1. css放在header里
2. 避免嵌套太多层: css解析--从右往左过滤查找，比如#test .class
3. 尽可能使用css, 减少js使用: 使用合理的布局如flex, css3等

三、cookie优化:
减少cookie的体积, 消除不必要的cookie

四、Server端：
使用cdn
Gzip components
Etags配置
html, js, css压缩合并: 减少http请求
预加载，懒加载


五、网络：
1. dns prefetch:
2. IP TCP HTTP的关系：
长连接
减少文件体积：js打包压缩，图片压缩，gzip
减少文件请求次数: 雪碧图，js,cs打包，缓存控制，懒加载
减少用户和服务器的距离：cdn
本地存储
浏览器缓存：
webpack打包和缓存的关系：
1. hash, 整个项目相关的hash
2. chunkhash, 入口文件依赖的chunkhash
3. contenthash文件内容的hash


浏览器渲染： how browsers work
白屏应对：骨架，自动化方案(page-skeleton-webpack-plugin), antd的skeleton组件
异步宏任务和微任务? event-loop   
    Macrotask/Microtask
    微任务优先级高于宏任务
    宏任务：setTimeout, setInterval, I/O, UI Rendering, script当中的所有代码， setImmediate(Node)
    微任务: process.nextTick(node) > Promise > MutationObserver
比如批量更新，比如我们要极短的时候操作100次数据，如果触发100次渲染可以复用event-loop, 在当前数据修改之后，汇总数据，统一修改，比如setState

五、
防抖节流: 减少代码执行次数
懒加载: 图片懒加载, 组件/路由懒加载(webpack做的)


六、算法优化


移动端优化技巧：
svg, 虚拟列表(解决列表过长浏览器产生雪崩,vue/react虚拟列表实现?), 300ms延迟(禁用缩放解决)
https://bvaughn.github.io/react-virtualized/#/components/List

prepack.io

React purcomponent
Vue async-component
webpack 可视化优化 webpack-bundle-analyzer


cdn没更新到，导致访问的那些用户还是旧的静态资源？到底怎么上线前端代码:
1. 先上html,还是先上js文件
如果先上html,加载的新的js还没有缓存生效 报错
如果先上js,老的html加载新的js,也会报错
2. 控制缓存：<script src="xxx?_t=100000"></script>
时间戳或者版本号后缀来控制缓存，但是对于通用的库，根本就没更新过内容，每次部署，都要重新加载，性能损耗
hash文件内容算出哈希(webpack)
3. cdn缓存：
通过html params的形式控制缓存，cdn上是不生效的(本地缓存可以生效，但cdn缓存需要一定的时间才会生效)
最后通过新文件的形式来控制缓存<script src="xxx_hash.js"></script>
每次文件变化，会生成新的文件，达到了控制cdn缓存的效果，定期清理硬盘



服务端渲染&&同构：
1. 服务端渲染，就是在服务端，解析首屏的组件产出html,直接返回
2. 如果用户跳转页面，同构，整个应用有两个入口
    server-entry首次进来的入口，使用ssr
    用户点击来的，单面应用，点击是不刷新的，走js单面入口，或者客户端渲染入口
3. 比如客户端渲染和ssr同时支持css, redux, react-router, 数据load等功能, seo支持等
nuxt等就是同构框架



企业中如何保证持续做好性能优化？
1. performance api+我们定制化的需求，配合google analyasisa或者百度统计做好性能监控，有大屏，或者dashboard查看性能分析结果
2. 性能监控 多端的监控，比如node,小程序，pc,h5等汇总的性能监控结果
3. 有针对性的去优化

